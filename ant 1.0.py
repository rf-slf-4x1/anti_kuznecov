# Для решения задачи получаем координаты начальной и конечной точки, центра дерева и радиуса
# Строим по двум точкам прямую - кратчайший путь муравья, и окружность - дерево
# Уравнение прямой определяется как: ((y1-y2)*x + (x2-x1)*y + (x1*y2 - x2*y1))
# Уравнение окружности определяется как: ((x-xd)**2 + (y-yd)**2 - r**2)
# Смотрим на пересечения прямой и окружности, которые ищем с помощью sym.solvers.solve
# Если пересечений нет, или пересечение одно, то есть путь муравья проходит по касательной,
# то дерево не мешает муравью двигаться и в данном случае мы просто находим расстояние между
# началом и концом пути: sqrt((x2-x1)**2+(y2-y1)**2)
# Если пересечений два, то необходимо обходить ствол, так как путь проходит через дерево
# Кратчайшее расстояние в таком случае - по двум касательным и дуге окружности - вокруг дерева
# Находим длину хорды, которая является отрезком пути муравья "внутри" дерева
# Формула для этого упоминалась выше
# Далее составляем систему уравнений и находим центральный угол
# Через него находим дугу окружности - вокруг дерева
# Также в программе происходит проверка на возможные ошибки
# Например когда муравей не двигается, стартует находясь внутри дерева,
# или когда решения переходят в комплексные числа
# График строю с помощь библиотеки matplotlib
# На нем отображаю дерево, начальную и конечную точку пути и прямую между ними
# Таким образом можно легко понять, как именно шел муравей и не ошиблась ли программа

# импорт необходимых модулей
import sympy as sym
import matplotlib.pyplot as plt

# получаем необходимые данные для начала решения
print('-'*40)
print('Решение задачи о муравье и дереве')
print()
x1 = float(input('Введите координату Х начальной точки: '))
y1 = float(input('Введите координату Y начальной точки: '))
x2 = float(input('Введите координату Х конечной точки: '))
y2 = float(input('Введите координату Y конечной точки: '))
xd = float(input('Введите координату Х центра дерева: '))
yd = float(input('Введите координату Y центра дерева: '))
r = float(input('Введите радиус ствола дерева: '))

print('-'*30)

# вывод полученных данных
p1 = (x1, y1)       # координаты начала пути
p2 = (x2, y2)       # координаты конца пути
pd = (xd, yd)       # координаты центра дерева

print(f'''Начальные координаты муравья: {p1}
Конечные координаты муравья: {p2}
Координаты центра дерева: {pd}
Радиус ствола: {r}''')

# Задаем х и у как координаты - переменные для символьного решения
x = sym.Symbol('x')
y = sym.Symbol('y')

pi = (sym.pi)       # задаем pi как переменую

# Составляем уравнение окружности - ствол дерева
uravn_circle = ((x-xd)**2 + (y-yd)**2 - r**2)

# Составляем уравнение прямой - пути
uravn_line = sym.simplify((y1-y2)*x + (x2-x1)*y + (x1*y2 - x2*y1))

# Находим количество пересечений этих уравнений
points = sym.solvers.solve([uravn_line, uravn_circle], (x, y))
number_of_elements = len(points)

print()
if x1 == x2 and y1 == y2:
    # проверяем, если координаты не изменились
    print('Муравей не сдвинулся с места')
else:
    # рассматриваем количество решений
    if number_of_elements == 1 or number_of_elements == 0:
        # Если муравей не упирался в ствол или прошел по касательной
        s1 = sym.sqrt((x2-x1)**2+(y2-y1)**2)        # расстояние строго между двумя точками
        print(f'На пути муравья нет дерева, его путь будет равен {s1}')

    elif number_of_elements == 2:        # если муравей уперся в ствол
        # проверяем на наличие ошибки
        str_points = str(points)
        if 'I' in str_points:
            print('Нет решений в декартовой системе координат')
        else:
            if (x1-xd)**2 + (y1-yd)**2 < r**2 or (x2-xd)**2 + (y2-yd)**2 < r**2:
                print('Ошибка входных данных! Координаты начала или конца пути лежат внутри дерева')

            else:
                m1 = (sym.sqrt((xd-x1)**2 + (yd-y1)**2 - r**2))     # длина касательной от начальной точки
                m2 = (sym.sqrt((x2-xd)**2 + (y2-yd)**2 - r**2))     # длина касательной от конечной точки
                # рассчитываем длину дуги между касательными
                k = ((y2-y1)/(x2-x1))
                temp_1 = (sym.sqrt((x-xd)**2 + (y-yd)**2 - r**2))
                temp_2 = (y-y1) - k * (x-x1)
                # точки пересечения хорды с окружностью находим через систему уравнений
                points_horda = sym.solve([temp_1, temp_2], (x, y))
                horda_x1 = points_horda [0][0]
                horda_y1 = points_horda [0][1]
                horda_x2 = points_horda [1][0]
                horda_y2 = points_horda [1][1]
                horda = sym.sqrt((horda_x2-horda_x1)**2+(horda_y2-horda_y1)**2)     # находим длину хорды
                alpha = (2 * (sym.asin((horda)/(2*r))))                             # находим центральный угол
                l = r * alpha

                # длина пути - две касательные плюс кусок дуги
                print(f'На пути муравья есть дерево, путь будет равен {m1 + m2 + l}')

                #Рисую график
                fig, ax = plt.subplots() 					# тело графика
                plt.title ("График для задачи")	    # название графика
                plt.xlabel("Ось X", fontsize=10, color='blue')		# ось абсцисс (x)
                plt.ylabel("Ось Y", fontsize=10, color='red') 		# ось ординат (y)
                points_one = points_horda [0]
                points_two = points_horda [1]
                plt.plot([p1[0], p2[0]], [p1[1], p2[1]])
                plt.scatter(horda_x1, horda_y1, s=12, c='red', marker="o", alpha = 1)
                plt.scatter(horda_x2, horda_y2, s=12, c='red', marker="o", alpha = 1)
                plt.scatter(x1, y1, s=40, c='purple', marker="o", alpha = 1)
                plt.scatter(x2, y2, s=40, c='purple', marker="o", alpha = 1)
                circle = plt.Circle((xd, yd), r, fill = False)
                ax.add_artist(circle)
                ax.grid(True)
                d = 2 * r
                ax.set_xlim(-2 * d, 2 * d)
                ax.set_ylim(-2 * d, 2 * d)

                plt.show()
